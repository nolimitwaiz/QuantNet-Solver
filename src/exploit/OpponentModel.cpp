#include "OpponentModel.hpp"
#include <algorithm>

namespace quantnet::exploit {

const ActionStats OpponentModel::empty_stats_ = ActionStats{};

void OpponentModel::observe_action(poker::PlayerId player,
                                   const poker::InfoSetId& info_set,
                                   const std::string& action) {
    stats_[player][info_set].observe(action);

    // Update aggregate profile
    auto& profile = profiles_[player];
    if (action == "raise" || action == "bet") {
        profile.pfr += 1;  // Will normalize later
    }
    if (action != "fold") {
        profile.vpip += 1;  // Put money in pot
    }
}

void OpponentModel::observe_hand_result(poker::PlayerId player,
                                        bool won,
                                        bool went_to_showdown,
                                        double /*pot_size*/) {
    auto& profile = profiles_[player];
    profile.total_hands++;

    if (went_to_showdown) {
        profile.went_to_showdown++;
        if (won) {
            profile.won_at_showdown++;
        }
    }
}

const ActionStats& OpponentModel::get_stats(poker::PlayerId player,
                                           const poker::InfoSetId& info_set) const {
    auto pit = stats_.find(player);
    if (pit == stats_.end()) return empty_stats_;

    auto iit = pit->second.find(info_set);
    if (iit == pit->second.end()) return empty_stats_;

    return iit->second;
}

TendencyProfile OpponentModel::get_profile(poker::PlayerId player) const {
    auto it = profiles_.find(player);
    if (it == profiles_.end()) {
        return TendencyProfile{};
    }

    TendencyProfile profile = it->second;

    // Normalize percentages
    if (profile.total_hands > 0) {
        profile.vpip /= profile.total_hands;
        profile.pfr /= profile.total_hands;
        profile.went_to_showdown /= profile.total_hands;
    }

    if (profile.went_to_showdown > 0) {
        profile.won_at_showdown /= (profile.went_to_showdown * profile.total_hands);
    }

    // Compute aggression factor from all observed actions
    int total_bets = 0, total_calls = 0;
    auto pit = stats_.find(player);
    if (pit != stats_.end()) {
        for (const auto& [info_set, stats] : pit->second) {
            total_bets += stats.raise_count;
            total_calls += stats.call_count;
        }
    }

    profile.aggression = (total_calls > 0) ?
        static_cast<double>(total_bets) / total_calls : 1.0;

    return profile;
}

Eigen::VectorXd OpponentModel::predict_action_probs(
    poker::PlayerId player,
    const poker::InfoSetId& info_set,
    int num_actions) const {

    const ActionStats& stats = get_stats(player, info_set);

    Eigen::VectorXd probs(num_actions);

    if (num_actions == 2) {
        // Assume: 0 = passive (check/call/fold), 1 = aggressive (bet/raise)
        probs(0) = stats.fold_freq() + stats.call_freq();
        probs(1) = stats.raise_freq();
    } else if (num_actions == 3) {
        // Assume: 0 = fold, 1 = call/check, 2 = raise/bet
        probs(0) = stats.fold_freq();
        probs(1) = stats.call_freq();
        probs(2) = stats.raise_freq();
    } else {
        // Uniform for unknown action space
        probs = Eigen::VectorXd::Constant(num_actions, 1.0 / num_actions);
    }

    // Normalize
    double sum = probs.sum();
    if (sum > 0) {
        probs /= sum;
    }

    return probs;
}

bool OpponentModel::has_sufficient_data(poker::PlayerId player,
                                       const poker::InfoSetId& info_set,
                                       int min_obs) const {
    return get_stats(player, info_set).has_sufficient_data(min_obs);
}

std::string OpponentModel::get_exploitation_advice(poker::PlayerId player) const {
    TendencyProfile profile = get_profile(player);
    std::string type = profile.classify();

    std::string advice;

    if (type == "Rock") {
        advice = "Opponent is tight-passive (Rock). "
                 "Steal blinds frequently, fold to their raises (they have it), "
                 "don't bluff the river.";
    } else if (type == "TAG") {
        advice = "Opponent is tight-aggressive (TAG). "
                 "Respect their raises, look for spots to 3-bet bluff preflop, "
                 "they will fold to pressure on scary boards.";
    } else if (type == "Fish") {
        advice = "Opponent is loose-passive (Fish). "
                 "Value bet relentlessly, don't bluff, bet bigger for value, "
                 "they will call with weak hands.";
    } else if (type == "LAG") {
        advice = "Opponent is loose-aggressive (LAG). "
                 "Trap with strong hands, let them bluff into you, "
                 "be prepared to call light on all streets.";
    } else if (type == "Calling Station") {
        advice = "Opponent is a calling station. "
                 "NEVER bluff, bet big with value hands, "
                 "they will call almost anything.";
    } else {
        advice = "Insufficient data to classify opponent. "
                 "Continue gathering observations.";
    }

    return advice;
}

Eigen::VectorXd OpponentModel::blend_with_nash(
    const Eigen::VectorXd& nash_probs,
    const Eigen::VectorXd& exploit_probs,
    double alpha) const {

    alpha = std::clamp(alpha, 0.0, 1.0);
    return (1.0 - alpha) * nash_probs + alpha * exploit_probs;
}

void OpponentModel::reset() {
    stats_.clear();
    profiles_.clear();
}

int OpponentModel::total_observations(poker::PlayerId player) const {
    int total = 0;
    auto pit = stats_.find(player);
    if (pit != stats_.end()) {
        for (const auto& [info_set, stats] : pit->second) {
            total += stats.total_observations;
        }
    }
    return total;
}

// ============================================================================
// ExploitativeStrategy
// ============================================================================

ExploitativeStrategy::ExploitativeStrategy(const OpponentModel& model,
                                           double exploitation_factor)
    : model_(model)
    , exploit_factor_(std::clamp(exploitation_factor, 0.0, 1.0)) {}

Eigen::VectorXd ExploitativeStrategy::compute_exploit_probs(
    poker::PlayerId /*our_player*/,
    poker::PlayerId opponent,
    const poker::InfoSetId& info_set,
    int num_actions) const {

    // Get opponent profile
    TendencyProfile profile = model_.get_profile(opponent);
    std::string type = profile.classify();

    // Get base exploitative strategy based on opponent type
    Eigen::VectorXd exploit_probs;

    if (type == "Rock") {
        exploit_probs = exploit_rock(num_actions);
    } else if (type == "Fish" || type == "Calling Station") {
        exploit_probs = exploit_fish(num_actions);
    } else if (type == "LAG") {
        exploit_probs = exploit_lag(num_actions);
    } else if (type == "TAG") {
        exploit_probs = exploit_tag(num_actions);
    } else {
        // Default to uniform
        exploit_probs = Eigen::VectorXd::Constant(num_actions, 1.0 / num_actions);
    }

    // If we have specific info set data, adjust further
    if (model_.has_sufficient_data(opponent, info_set)) {
        Eigen::VectorXd opp_probs = model_.predict_action_probs(opponent, info_set, num_actions);

        // Exploit their tendencies: do the opposite of what they expect
        // If they fold a lot, bluff more
        // If they call a lot, value bet more
        if (opp_probs(0) > 0.5) {
            // They fold/passive a lot - be more aggressive
            if (num_actions >= 2) exploit_probs(num_actions - 1) += 0.2;
        } else if (num_actions >= 2 && opp_probs(num_actions - 1) > 0.3) {
            // They are aggressive - trap more (be passive with strong hands)
            exploit_probs(0) += 0.2;
        }

        // Renormalize
        double sum = exploit_probs.sum();
        if (sum > 0) exploit_probs /= sum;
    }

    return exploit_probs;
}

Eigen::VectorXd ExploitativeStrategy::exploit_rock(int num_actions) const {
    // Vs Rock: Bluff more, fold to aggression
    Eigen::VectorXd probs(num_actions);
    if (num_actions == 2) {
        probs(0) = 0.3;   // Less passive
        probs(1) = 0.7;   // More aggressive (they fold too much)
    } else if (num_actions == 3) {
        probs(0) = 0.1;   // Fold less
        probs(1) = 0.3;   // Call less
        probs(2) = 0.6;   // Raise more
    } else {
        probs = Eigen::VectorXd::Constant(num_actions, 1.0 / num_actions);
    }
    return probs;
}

Eigen::VectorXd ExploitativeStrategy::exploit_fish(int num_actions) const {
    // Vs Fish: Value bet, don't bluff
    Eigen::VectorXd probs(num_actions);
    if (num_actions == 2) {
        probs(0) = 0.4;   // Check/call with medium hands
        probs(1) = 0.6;   // Bet with value (they'll call)
    } else if (num_actions == 3) {
        probs(0) = 0.0;   // Never fold (they call anyway)
        probs(1) = 0.3;   // Call sometimes
        probs(2) = 0.7;   // Bet big for value
    } else {
        probs = Eigen::VectorXd::Constant(num_actions, 1.0 / num_actions);
    }
    return probs;
}

Eigen::VectorXd ExploitativeStrategy::exploit_lag(int num_actions) const {
    // Vs LAG: Trap, let them bluff
    Eigen::VectorXd probs(num_actions);
    if (num_actions == 2) {
        probs(0) = 0.6;   // Check/call more (trap)
        probs(1) = 0.4;   // Bet less (let them bet)
    } else if (num_actions == 3) {
        probs(0) = 0.1;   // Don't fold light
        probs(1) = 0.5;   // Call down
        probs(2) = 0.4;   // Reraise with strong hands
    } else {
        probs = Eigen::VectorXd::Constant(num_actions, 1.0 / num_actions);
    }
    return probs;
}

Eigen::VectorXd ExploitativeStrategy::exploit_tag(int num_actions) const {
    // Vs TAG: 3-bet bluff preflop, apply pressure on scary boards
    Eigen::VectorXd probs(num_actions);
    if (num_actions == 2) {
        probs(0) = 0.4;   // Can fold to their raises
        probs(1) = 0.6;   // But also fight back
    } else if (num_actions == 3) {
        probs(0) = 0.2;   // Fold to strong lines
        probs(1) = 0.3;   // Call medium strength
        probs(2) = 0.5;   // Pressure back
    } else {
        probs = Eigen::VectorXd::Constant(num_actions, 1.0 / num_actions);
    }
    return probs;
}

} // namespace quantnet::exploit
