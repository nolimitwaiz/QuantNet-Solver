#pragma once

#include <map>
#include <string>
#include <vector>
#include <cmath>
#include <Eigen/Dense>
#include "../poker/GameTypes.hpp"

namespace quantnet::exploit {

// Statistics for actions at an information set
struct ActionStats {
    int fold_count = 0;
    int call_count = 0;
    int raise_count = 0;
    int total_observations = 0;

    // Add observation of an action
    void observe(const std::string& action) {
        if (action == "fold") fold_count++;
        else if (action == "call" || action == "check") call_count++;
        else if (action == "raise" || action == "bet") raise_count++;
        total_observations++;
    }

    // Frequency estimates with Laplace smoothing
    double fold_freq(double prior = 1.0) const {
        return (fold_count + prior) / (total_observations + 3 * prior);
    }

    double call_freq(double prior = 1.0) const {
        return (call_count + prior) / (total_observations + 3 * prior);
    }

    double raise_freq(double prior = 1.0) const {
        return (raise_count + prior) / (total_observations + 3 * prior);
    }

    // Confidence in estimate (based on sample size)
    double confidence() const {
        // Confidence increases with observations
        // Returns value in [0, 1]
        return 1.0 - 1.0 / (1.0 + 0.1 * total_observations);
    }

    // Has enough data for exploitation
    bool has_sufficient_data(int min_obs = 10) const {
        return total_observations >= min_obs;
    }
};

// Player tendency profile
struct TendencyProfile {
    double vpip = 0.0;           // Voluntarily put $ in pot
    double pfr = 0.0;            // Pre-flop raise %
    double aggression = 0.0;     // (bets + raises) / calls
    double went_to_showdown = 0.0; // % of hands that went to showdown
    double won_at_showdown = 0.0;  // % wins when reaching showdown

    int total_hands = 0;

    // Classify player type
    std::string classify() const {
        if (vpip < 0.2 && aggression < 0.8) return "Rock";       // Tight-passive
        if (vpip < 0.25 && aggression > 1.2) return "TAG";       // Tight-aggressive
        if (vpip > 0.35 && aggression < 0.8) return "Fish";      // Loose-passive
        if (vpip > 0.35 && aggression > 1.2) return "LAG";       // Loose-aggressive
        if (vpip > 0.5) return "Calling Station";                // Very loose-passive
        return "Unknown";
    }
};

// Opponent model tracks statistics and predicts opponent behavior
class OpponentModel {
public:
    OpponentModel() = default;

    // Observe an action at an information set
    void observe_action(poker::PlayerId player,
                        const poker::InfoSetId& info_set,
                        const std::string& action);

    // Observe hand result
    void observe_hand_result(poker::PlayerId player,
                             bool won,
                             bool went_to_showdown,
                             double pot_size);

    // Get action frequencies at info set
    const ActionStats& get_stats(poker::PlayerId player,
                                 const poker::InfoSetId& info_set) const;

    // Get player tendency profile
    TendencyProfile get_profile(poker::PlayerId player) const;

    // Predict action distribution
    Eigen::VectorXd predict_action_probs(poker::PlayerId player,
                                         const poker::InfoSetId& info_set,
                                         int num_actions = 2) const;

    // Check if we have enough data for reliable prediction
    bool has_sufficient_data(poker::PlayerId player,
                            const poker::InfoSetId& info_set,
                            int min_obs = 10) const;

    // Exploitation suggestions
    std::string get_exploitation_advice(poker::PlayerId player) const;

    // Blend with Nash strategy
    // Returns strategy that is (1-alpha)*nash + alpha*exploit
    Eigen::VectorXd blend_with_nash(const Eigen::VectorXd& nash_probs,
                                   const Eigen::VectorXd& exploit_probs,
                                   double alpha) const;

    // Reset all statistics
    void reset();

    // Get number of observations for a player
    int total_observations(poker::PlayerId player) const;

private:
    // Stats per player per info set
    std::map<poker::PlayerId, std::map<poker::InfoSetId, ActionStats>> stats_;

    // Aggregate stats per player
    std::map<poker::PlayerId, TendencyProfile> profiles_;

    // Empty stats for when no data exists
    static const ActionStats empty_stats_;
};

// Exploitative strategy generator
class ExploitativeStrategy {
public:
    ExploitativeStrategy(const OpponentModel& model,
                         double exploitation_factor = 0.5);

    // Compute exploitative action probabilities
    // Returns action distribution that exploits opponent tendencies
    Eigen::VectorXd compute_exploit_probs(
        poker::PlayerId our_player,
        poker::PlayerId opponent,
        const poker::InfoSetId& info_set,
        int num_actions) const;

    // Get exploit factor (0 = pure Nash, 1 = max exploit)
    double get_factor() const { return exploit_factor_; }
    void set_factor(double f) { exploit_factor_ = std::clamp(f, 0.0, 1.0); }

private:
    const OpponentModel& model_;
    double exploit_factor_;

    // Compute exploitative response to opponent tendencies
    Eigen::VectorXd exploit_rock(int num_actions) const;      // Vs tight-passive
    Eigen::VectorXd exploit_fish(int num_actions) const;      // Vs loose-passive
    Eigen::VectorXd exploit_lag(int num_actions) const;       // Vs loose-aggressive
    Eigen::VectorXd exploit_tag(int num_actions) const;       // Vs tight-aggressive
};

} // namespace quantnet::exploit
